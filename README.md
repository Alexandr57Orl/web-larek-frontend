# Проектная работа "Веб-ларек"

Стек: HTML, SCSS, TS, Webpack

Структура проекта:

- src/ — исходные файлы проекта
- src/components/ — папка с JS компонентами
- src/components/base/ — папка с базовым кодом

Важные файлы:

- src/pages/index.html — HTML-файл главной страницы
- src/types/index.ts — файл с типами
- src/index.ts — точка входа приложения
- src/scss/styles.scss — корневой файл стилей
- src/utils/constants.ts — файл с константами
- src/utils/utils.ts — файл с утилитами

## Установка и запуск

Для установки и запуска проекта необходимо выполнить команды

```
npm install
npm run start
```

или

```
yarn
yarn start
```

## Сборка

```
npm run build
```

или

```
yarn build
```

# Данные и типы данных, используемые в приложении

### Интерфейс для карточки товара

```

export interface IItemsProduct {
id: string; // идентификатор карточки
description: string; // описание карточки
image: string; // ссылка на изображение
title: string; // название товара
category: Tcategory; // категория товара
price: number; // цена товара
}
```

### Интерфейс открытой для просмотра карточки товара

```
export interface ICardsData {
produts: IItemsProduct[]; // массив карточек
show: string | null; // указатель на ту карточку, которую мы хотим просмотреть
}
```

### Интерфейс для модели данных об пользователе

```
export interface IUserData {
email: string; // почта
mobile: string; // телефон
adress: string; // адрес
typePay: ChoicePay; // выбранный способ оплаты
getUserData: IUserData; // данные пользователя
}
```

### Интерфейс для каталога товара

```
export interface ICatalog {
products: IItemsProduct[]; // массив карточек
show: string | null; // указатель на ту карточку, которую мы хотим просмотреть
getCatalog: ICatalog;
showOneItem(item: string): void; //открываем карточку для просмотра по id
getItemsProduct(): IItemsProduct[]; //получаем массив карточек с сервера
saveItemsProduct(): IItemsProduct[]; //сохраняем массив карточек
}
```

### Интерфейс для корзины

```
export interface IBasket {
items: IItemsProduct[]; // карточки в корзине
add(id: string): void; // добавить карточку в корзину
remove(id: string): void; // удалить карточку из корзины
resetBasket(): void; // очистить корзину
}
```

### Интерфейс для заказа

```
export interface IResOred {
typePay: ChoicePay; // тип оплаты
adress: string; // адрес доставки
email: string; // почта
mobile: string; // телефон
items: IItemsProduct[]; // массив карточек
total: number | null; // итого, что находится в корзине
}
```

# Общие типы для приложения

### Принимаемый тип данных для опции выбора способа оплаты

```
export type ChoicePay = 'card' | 'cash';
```

### Принимаемый тип данных для категории товара

```
export type Tcategory =
	| 'софт-скилл'
	| 'другое'
	| 'дополнительное'
	| 'кнопка'
	| 'хард-скилл';
```

## Работа с типом данных модального окна

### Принимаемый тип данных для модального окна со способом оплаты

```
export type IPaymentModal = Pick<IUserData, `adress`>;
```

### Принимаемый тип данных для модального окна с информацией о пользователе

```
export type IUserModal = Pick<IUserData, `email` | `mobile`>;
```

### Принимаемый тип данных для модального окна с информацией о успешном совершении заказа

```
export type IOrderSuccessPopup = Pick<IResOred, 'total'>;
```

### Принимаемый тип данных для отображения добавленного товара(карточки) в корзине

```
export type IPopupItemInBacket = Pick<IItemsProduct, 'title' | 'price'>;
```

# Архитектура приложения

## Код приложения разделен на слои согласно парадигме MVP:

- _слой представления_, отвечает за отображение данных на странице - View
- _слой данных_, отвечает за хранение и изменение данных - Models
- _презентер_, отвечает за связь представления и данных - Presenter

## Класс Api

Содержит в себе базовую логику отправки запросов. В конструктор передается базовый адрес сервера и опциональный объект с заголовками запросов.

`constructor(baseUrl: string, options: RequestInit = {})` - принимает базовый URL и глобальные опции для всех запросов(опционально).

Реализует логику работы с сервером. Содержит конструктор для создания объекта со свойствами базового url адреса и хэдеров запроса. Также содержит `get` и `post` методы.

`get` - _выполняет GET запрос на переданный в параметрах ендпоинт и возвращает промис с объектом, которым ответил сервер_

`post` - _принимает объект с данными, которые будут переданы в JSON в теле запроса, и отправляет эти данные на ендпоинт переданный как параметр при вызове метода. По умолчанию выполняется POST запрос, но метод запроса может быть переопределен заданием третьего параметра при вызове._

## Класс `EventEmitter`

Данный класс - является брокером событий, который позволяет отправлять события, а также подписываться на события, происходящие в системе. Конструктор создает пустой объект `Map`, который будет хранить события и их подписчиков. Класс используется в презентере для обработки событий и в слоях приложения для генерации событий.

## \* Основные методы, реализуемые классом описаны интерфейсом `IEvents`:

метод `on` - Установливает обработчик на событие;

метод `of` - Снимает обработчик с события;

метод `emit` - Инициирует событие с данными;

метод `onAll` - Устанавливает слушатель на все события;

метод `offAll` - удаляет все обработчики для всех событий;

метод `trigger` - создает и возвращает функцию-триггер, которая в свою очередь генерирует событие с указанным именем и данными.
