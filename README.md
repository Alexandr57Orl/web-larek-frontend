# Проектная работа "Веб-ларек"

Стек: HTML, SCSS, TS, Webpack

Структура проекта:

- src/ — исходные файлы проекта
- src/components/ — папка с JS компонентами
- src/components/base/ — папка с базовым кодом

Важные файлы:

- src/pages/index.html — HTML-файл главной страницы
- src/types/index.ts — файл с типами
- src/index.ts — точка входа приложения
- src/scss/styles.scss — корневой файл стилей
- src/utils/constants.ts — файл с константами
- src/utils/utils.ts — файл с утилитами

## Установка и запуск

Для установки и запуска проекта необходимо выполнить команды

```
npm install
npm run start
```

или

```
yarn
yarn start
```

## Сборка

```
npm run build
```

или

```
yarn build
```

# Данные и типы данных, используемые в приложении

### Интерфейс для единицы товара

```

export interface IItemsProducts {
	id: string; - идентификатор карточки
	description: string; - описание карточки
	image: string; - ссылка на изображение
	title: string; - название товара
	category: Tcategory; - категория товара
	price: number; - цена товара
}
```

### Интерфейс для данных о пользователе

```
export interface IUser{
    email: string; - почта
	mobile: string; - телефон
	adress: string; - адрес
	typePay: ChoicePay; - выбранный способ оплаты
	products: string[]; - массив продуктов
	total: number | null; - общая сумма товаров, добавленных в корзину
	checkValidation(data: Record<keyof TForm, string | number>): boolean; - проверка валидации формы
}
```

### Интерфейс состояния сайта

```
export interface ChechedState {
	products: IItemsProducts[]; - массив карточек
	show: string | null; - указатель на ту карточку, которую мы хотим просмотреть
	basket: IItemsProducts[]; - массив карточек в корзине;
	order: IUser; - данные пользователя
	showOneItem: (product: IItemsProducts[], id: string) => void; - открываем карточку для просмотра по id
	addItems: (productId: string, payloader: Function | null) => void; - добавляем карточку в корзину используя id
	updateItem: (product: IItemsProducts, payloader: Function | null) => void; - обновляем карточку
	saveItemsProduct: () => IItemsProducts[]; - сохраняем массив карточек
	removeItemsInBasket: (productId: string, payloader: Function | null) => void; - удаляем карточку из корзины используя id
	clearBasket: () => void; //очищаем корзину
}
```

### Интерфейс для получения итогов заказа

```
export interface IResOred {
	id: string; // идентификатор заказа
	total: number | null; //общая сумма товаров, добавленных в корзину
}
```

# Общие типы для приложения

### Принимаемый тип данных для опции выбора способа оплаты

```

export type ChoicePay = 'card' | 'cash';

```

### Принимаемый тип данных для категории товара

```

export type Tcategory =
| 'софт-скилл'
| 'другое'
| 'дополнительное'
| 'кнопка'
| 'хард-скилл';

```

# Архитектура приложения

## Код приложения разделен на слои согласно парадигме MVP:

- _слой данных_, `Model` Модель отвечает за бизнес-логику приложения, управление данными и операции с данными, такие как загрузка, сохранение и изменение данных. Модель не зависит от пользовательского интерфейса и не содержит логику отображения, что делает ее переиспользуемой в различных интерфейсах.
- _слой отображения_, `View`отвечает за отображение данных пользователю и взаимодействие с пользователем. Оно получает данные, которые необходимо отобразить, от Presenter'а и просто реализует логику их визуализации, без ведения каких-либо операций над данными.

- _презентер_,`Presenter` отвечает за управление логикой приложения и обмен данными между моделью (Model) и представлением (View).

# Основные классы приложения

## Класс BaseComponents

Данный класс является `абстактным` и облегчает взаимодействие с DOM-элементами в рамках компонентов, а также способствует более простой разработке интерфейса, предоставляя возможности для создания и контроля над компонентами на сайте. Благодаря классу BaseComponents, который может служить основой для других компонентов в приложении, они получают доступ к стандартному набору инструментов для манипуляций с DOM.

В `constructor` принимает `container` и сохраняет его. Конструктор защищен, что означает, что нельзя создавать экземпляры этого класса напрямую в объекте, но его можно вызывать из подклассов.

### BaseComponents содержит следующие методы:

- render() - данный метод способствует отображению данных и обновлению данных экземпляра класса, копируя свойства из data в текущий объект с использованием Object.assign.
- setImageElement - устанавливает источник изображения, а также в случае не прогрузки изображения отображает альтернативный текст.
- setTextElement - устанавливает текстовое содержимое элемента.
- toggleClassElement - переключения класса у элемента. Использует classList.toggle для добавления или удаления класса.
- setDisabledElement - добавляет/удаляет атрибут disabled у элемента.
- setVisibleElement - отображает элемент.
- setHidenElement - скрыает элемент.

## Класс Api

Содержит в себе базовую логику отправки запросов. В конструктор передается базовый адрес сервера и опциональный объект с заголовками запросов.

`constructor(baseUrl: string, options: RequestInit = {})` - принимает базовый URL и глобальные опции для всех запросов(опционально).

Реализует логику работы с сервером. Содержит конструктор для создания объекта со свойствами базового url адреса и хэдеров запроса. Также содержит `get` и `post` методы.

`get` - _выполняет GET запрос на переданный в параметрах ендпоинт и возвращает промис с объектом, которым ответил сервер_

`post` - _принимает объект с данными, которые будут переданы в JSON в теле запроса, и отправляет эти данные на ендпоинт переданный как параметр при вызове метода. По умолчанию выполняется POST запрос, но метод запроса может быть переопределен заданием третьего параметра при вызове._

## Класс `EventEmitter`

Данный класс - является брокером событий, который позволяет отправлять события, а также подписываться на события, происходящие в системе. Конструктор создает пустой объект `Map`, который будет хранить события и их подписчиков. Класс используется в презентере для обработки событий и в слоях приложения для генерации событий.

## Основные методы, реализуемые классом описаны интерфейсом `IEvents`:

метод `on` - Установливает обработчик на событие;

метод `of` - Снимает обработчик с события;

метод `emit` - Инициирует событие с данными;

метод `onAll` - Устанавливает слушатель на все события;

метод `offAll` - удаляет все обработчики для всех событий;

метод `trigger` - создает и возвращает функцию-триггер, которая в свою очередь генерирует событие с указанным именем и данными.

# Слой данных `Model`

## Класс UserData

Данный класс отвечает за данные пользователя и логику работы с этими данными.
Функция-конструктор принимает инстанс брокера событий
Содержит следующие поля:

```

    email: string; // хранит данные почты пользователя
    mobile: string; // хранит данные телефона пользователя
    adress: string; // хранит адрес пользователя
    typePay: ChoicePay; // хранит выбранный способ оплаты пользователя

```

Класс UserDate также имеет следующие методы:

```

checkValidation(data: Record<keyof TForm, string | number>): boolean; //проверка валидации формы
функция get() - для доступа и set() - для работы со свойствами объекта-инстанса этого класса

```

## Класс ChechedStateData

Класс отвечает за хранение и логику работы с данными карточки продукта.
Конструктор класса принимает инстант брокера событий.
В полях класса хранятся следующие данные:

```

    products: IItemsProducts[]; - массив карточек
    show: string | null; - указатель на ту карточку, которую мы хотим просмотреть
    basket: IItemsProducts[]; - массив карточек в корзине;
    order: IUser; - данные пользователя

```

### Методы класса для взаимодействия с данными:

- showOneItem: (product: IItemsProducts[], id: string) => void; открываем карточку для просмотра по id
- addItems: (productId: string, payloader: Function | null) => void; обавляем карточку в корзину используя id
- updateItem: (product: IItemsProducts, payloader: Function | null) => void; обновляем карточку
- saveItemsProduct: () => IItemsProducts[]; //сохраняем массив карточек
- removeItemsInBasket: (productId: string, payloader: Function | null) => void; удаляем карточку из корзины используя id
- clearBasket: () => void; //очищаем корзину

- функции get(), set(); для доступа и работы со свойствами объекта-инстанса этого класса

# Слой отображения `View`

### Данный слой используется для отображения данных на экране.

## Класс `Card`

Это класс, отвечающий за отображение карточек на главной странице, в модальном окне просмотра карточки и в корзине.
В конструкторе класса передается DOM элемент темплейта, что позволяет при необходимости формировать карточки разных вариантов верстки.
В классе устанавливаются слушатели на все интерактивные элементы, в результате взаимодействия с которыми пользователя генерируются соответствующие события.
Поля класса содержат элементы разметки карточки.
Конструктор, кроме темплейта, принимает экземпляр EventEmitter для инициации событий.

### Методы класса:

#### Сеттеры

- title устанавливает текст заголовка
- category устанавливает текст описания
- image устанавливает URL изображения.
- price устанавливает цену. Если цена равна null, кнопка действия блокируется, и текст цены устанавливается в "Бесценно"
- id устанавливает идентификатор товара
- category устанавливает категорию товара и добавляет соответствующий CSS класс

## Класс `Page`

Этот класс управляет показом блока карточек на стартовой странице. Конструктору передаётся контейнер для размещения карточек. Метод render использует предоставленный массив элементов карточек для их отображения в заданном контейнере.

# Слой Коммуникации `Presenter` отвечающий за взаимодействие компнонетов

## Класс AppApi (не забыть добавить интерфейсы и типы)

Принимает в конструктор экземпляр класса Api, а именно (`cdn` cтрока, представляющая URL до контента CDN;
`baseUrl` Базовый URL для API;
`options` Опциональные настройки для запросов) и предоставляет методы реализующие взаимодействие с бэкендом сервиса.

Методы данного класса:

- getItemsElement - Отправляет GET-запрос на путь /product/ и обрабатывает полученные данные.
- response(): Обработка ответа от сервера
- createOrder - Отправляет POST-запрос с данными заказа на путь /order и возвращает промис

Взаимодействие осуществляется за счет событий, генерируемых с помощью брокера событий и их обработчиков описанных в events.ts
В events.ts сначала создаются экземпляры всех необходимых классов, а затем настраивается обработка событий.

Список событий, которые могут генерироваться в системе:

```

-cardsItems:changed - изменение массива карточек товаров.

-basket:open- открытие модального окна с содержимым корзины.

-basketData:changed - изменение данных в корзине товаров

-userInfoUpgrade - изменение данных о пользователе (adress,mobile,email)

```

### События, при взаимодействии пользователя с интерфейсом

```

-mobile:input - ввод телефона клиента.

-email:input - ввод почтового адреса клиента.

-address:input - ввод адреса доставки заказа.

-order:submit - подтверждение данных для оплаты и доставки.

-contacts:submit - подтверждение контактных данных.

-card:delete - удаление товара из корзины

-choice-pay: change - выбор оплаты

-order:complete - при открытии окна успешной оплаты

```

```

```
